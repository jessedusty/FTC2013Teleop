#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightDrive,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     spinner,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     armmove,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    grabspin,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    rightrotate,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    leftrotate,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// THIS IS THE MAIN DRIVE CODE - FOR USE IN TELEOP, THIS FILE HAS BEEN CREATED ON Nov 25th, 2012


#include "JoystickDriver.c" // ABSOLUTLY CRUTIAL FOR DRIVING WITH A JOYSTICK

// VD - varible declarations
int rev = 1; // 1 = not reversed | -1 means reversed
bool normalctl = true; // normal joystick configuration if true, reverse joystick configuration if false
int power = 1; // the number that joystick is divided by to give
int forwardbackwardthresh = 10; // this is the threshold for the left joystick in leftmode
int leftrightthresh = 10; // this is the threshhold for the right joystick in left mode
bool leftmode = true; //leftmode is when up/down is on left and left/right is on right
bool rightmode = false; // rightmode the reverse of leftmode
bool isRunning = true; // specifies wether the robot is not in E-STOP mode - will stop all robot actions if set to false
int quadrent = 0;

// values set throughout the program
float leftmotorval = 0;
float rightmotorval = 0;
float leftstickval = 0;
float rightstickval = 0;
float newrightstickval = 0;

// end of "global" varible declaration

// make sure that the values going to the motor arn't less than -100 or greater than 100
float makesureitsinlimits(float input) {
  if (input > 100) input = 100;
  if (input < -100) input = -100;
  return input;
}

// driving joystick (the one that actually moves the robot's position)

void joyval_joystick1st() { // standard mode on left joystick

  leftstickval = pow(((float)joystick.joy1_y1 / (float)64 * (float)5), 2) ;
  if (joystick.joy1_y1 < 0) leftstickval = leftstickval * -1.0;

  rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
  if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;

}

void joyval_joystick1rv() { // reverse mode on left joystick
  leftstickval = pow(((float)joystick.joy1_y2 / (float)64 * (float)5), 2) ;
  if (joystick.joy1_y2 < 0) leftstickval = leftstickval * -1.0;

  rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
  if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;
}

void joyval_joystick2st() { // standard mode on right joystick
  leftstickval = pow(((float)joystick.joy2_y1 / (float)64 * (float)5), 2) ;
  if (joystick.joy2_y1 < 0) leftstickval = leftstickval * -1.0;

  rightstickval = pow(((float)joystick.joy2_x2 / (float)64 * (float)5), 2) ;
  if (joystick.joy2_x2 < 0) rightstickval = rightstickval * -1.0;
}

void joyval_joystick2rv() { // reverse mode on right joystick
  leftstickval = pow(((float)joystick.joy2_y2 / (float)64 * (float)5), 2) ;
  if (joystick.joy2_y2 < 0) leftstickval = leftstickval * -1.0;

  rightstickval = pow(((float)joystick.joy2_x1 / (float)64 * (float)5), 2) ;
  if (joystick.joy2_x1 < 0) rightstickval = rightstickval * -1.0;
}

//discover the values for use in the driving routine (using above methods)
void joyval_correct() {
  if ((normalctl) & (rev == 1)) {
    joyval_joystick1st();
    } else if ((normalctl) & (rev == -1)) {
    joyval_joystick1rv();
    } else if ((!normalctl) & (rev == 1)) {
    joyval_joystick2st();
    } else if ((!normalctl) & (rev == -1)) {
    joyval_joystick2rv();
    } else {
    PlayImmediateTone(500, 1);
  }
  leftstickval = leftstickval * rev;
  if (abs(leftstickval) < forwardbackwardthresh) leftstickval = 0;
  //rightstickval = rightstickval * -1.0
  if (abs(rightstickval) < leftrightthresh) rightstickval = 0;
}

float whichismax(float left, float right) {
  float returnval;
  if (left > right) returnval = left;
  if (right > left) returnval = right;
  if (right == left) returnval = (left + right) / 2;
  return returnval;
}

//MTR - move the motors, where the main drive motors are driven
void movethemotors() {
  motor[leftDrive] = leftmotorval;
  motor[rightDrive] = rightmotorval;
}

//DJ - where the main driving happens (it calls the other stuff above)
void driving_joystick() {
  joyval_correct(); //put the correct joystick values in their varibles
  if (leftstickval > 0.0) {
    if (rightstickval > 0.0) {
      quadrent = 1;
      leftmotorval = leftstickval - rightstickval;
      rightmotorval = whichismax(leftstickval, rightstickval);
      } else {
      quadrent = 2;
      leftmotorval = whichismax(leftstickval, (rightstickval * -1.0));
      rightmotorval = leftstickval + rightstickval;
    }
    } else {
    if (rightstickval > 0.0) {
      quadrent = 3;
      leftmotorval = (whichismax((leftstickval * -1.0), rightstickval)) * -1.0;
      rightmotorval = leftstickval + rightstickval;
      } else {
      quadrent = 4;
      leftmotorval = leftstickval - rightstickval;
      rightmotorval = (whichismax((leftstickval * -1.0), (rightstickval * -1.0))) * -1.0;
    }
  }

  movethemotors();
}

// power control (used for slowing down driving motors to get greater accuracy)

void powercontrol () {
  if (normalctl) {
    if (joy1Btn(1)) power = 1;
    if (joy1Btn(2)) power = 2;
    if (joy1Btn(3)) power = 3;
    if (joy1Btn(4)) power = 4;
    } else {
    if (joy2Btn(1)) power = 1;
    if (joy2Btn(2)) power = 2;
    if (joy2Btn(3)) power = 3;
    if (joy2Btn(4)) power = 4;
  }
}

// accesory controler contols

void ballpickup () {
if (normalctl) {
  if (abs(joystick.joy1_x2) > 50) {
    motor[spinner] = joystick.joy1_x2 * -1;
    } else {
    motor[spinner] = 0;
  }
  } else {
  if (abs(joystick.joy2_x1) > 50) {
    motor[spinner] = joystick.joy2_y2;
    } else {
    motor[spinner] = 0;
  }
}
}

void gripbasket () {
  if (normalctl) {
    if (joy1Btn(4)) {
      servo[grabspin] = 10;
    } else if (joy1Btn(2)) {
    servo[grabspin] = 128;
  }
  } else {
	  if (joy1Btn(4)) {
      servo[grabspin] = 10;
    } else if (joy1Btn(2)) {
    servo[grabspin] = 128;
  }
}
}


void armturn () {
  if (normalctl) {
    if (joy1Btn(8)) {

      servo[leftrotate] = 0;
      servo[rightrotate] = 255;
      } else if (joy1Btn(7)) {



      servo[leftrotate] = 255;
      servo[rightrotate] = 0;
      } else {
      servo[leftrotate] = 128;
      servo[rightrotate] = 128;
    }
    } else {
    if (joy1Btn(8)) {
      servoChangeRate[leftrotate] = 1;
      servoChangeRate[rightrotate] = 1;
      servo[leftrotate] = 108;
      servo[rightrotate] = 148;
      } else if (joy1Btn(7)) {
      servoChangeRate[leftrotate] = 1;
      servoChangeRate[rightrotate] = 1;
      servo[leftrotate] = 148;
      servo[rightrotate] = 108;
      } else {
      servo[leftrotate] = 128;
      servo[rightrotate] = 128;
    }
  }
}

void armmovecheck () {
  if (normalctl) {
  if (abs(joystick.joy1_y2) > 40) {
    motor[armmove] = joystick.joy1_y2 * -1;
    } else {
    motor[armmove] = 0;
  }
} else {
 if (abs(joystick.joy1_y1) > 20) {
    motor[armmove] = joystick.joy1_y1;
    } else {
    motor[armmove] = 0;
  }
}
}

void mainaccessory () {
  gripbasket();
  gripbasket();
  armturn();
  ballpickup();
}


// BC - battery check
void batterycheck () {
  if (externalBattery == -1) PlayImmediateTone(4000, 1);
}

// TMT this is the main thread code
task main() {
  waitForStart();
  isRunning = true; // sets isRunning to true, just in case it gets set to false

  while (isRunning) {
    getJoystickSettings(joystick);
    driving_joystick();
    armmovecheck();
    mainaccessory();
    batterycheck();
    //powercontrol();

  }
}
